#version 330

uniform samplerCube cubeMap;
uniform float far;
uniform float near;
uniform float w_light;
#define BIAS 0.01

uniform vec3 poisson_blocker[16] =vec3[16](
vec3(-0.0261426734268, 0.0396211660525, -0.998872726541) ,
vec3(-0.0946655462544, 0.759503735069, 0.64357789798) ,
vec3(0.803527975639, 0.584959691527, -0.110294839653) ,
vec3(-0.743364376081, 0.640999675877, -0.191125141987) ,
vec3(0.0703918441035, -0.150835915179, 0.986049448545) ,
vec3(0.436062244795, -0.836022986549, -0.333039464066) ,
vec3(-0.257562737239, 0.658433476235, -0.707196432231) ,
vec3(-0.537396679213, -0.840909822648, 0.0638394810865) ,
vec3(-0.578181456111, 0.199584119279, 0.791120966187) ,
vec3(-0.430826267228, -0.579647128782, -0.691663164815) ,
vec3(0.786413950685, -0.358760173306, 0.502836192232) ,
vec3(0.0977067087043, -0.831683422311, 0.546585843329) ,
vec3(0.1853544812, 0.961226302491, -0.204175688313) ,
vec3(0.948804964831, -0.261049628611, -0.177826404437) ,
vec3(0.609316029136, 0.556799594986, 0.564542458688) ,
vec3(-0.921490589959, -0.260929695327, -0.287699125326) );


uniform vec3 poisson_pcf[32] =vec3[32](
vec3(0.390457764503, -0.709811888145, -0.5862677013) ,
vec3(0.0842151728043, 0.477202796796, -0.874748704143) ,
vec3(-0.0821720991787, -0.176916237157, 0.980789677325) ,
vec3(-0.616552736106, -0.262551713926, -0.742246132435) ,
vec3(-0.14593204446, -0.977057457905, -0.155121121554) ,
vec3(0.746784333843, -0.597847185521, 0.291362148351) ,
vec3(0.635894134373, 0.47269694786, -0.610078884533) ,
vec3(-0.0239886715872, -0.0157815206351, -0.999587658608) ,
vec3(0.254908179989, 0.369081359991, 0.893756549336) ,
vec3(-0.35681841232, 0.682035478666, 0.638363710176) ,
vec3(0.299162630702, -0.818430741601, 0.490584184003) ,
vec3(-0.377232508821, -0.750754910407, 0.542275482378) ,
vec3(-0.584084981259, 0.81165028896, 0.00827907595431) ,
vec3(0.74791275594, 0.663084804168, 0.0307416977888) ,
vec3(0.260771039843, 0.930695392452, 0.25652397792) ,
vec3(-0.377275616948, 0.756442642304, -0.53428235771) ,
vec3(0.729801019068, 0.2551716189, 0.634253827324) ,
vec3(0.255951310564, 0.859258845673, -0.442903107635) ,
vec3(-0.119063042615, -0.682877609946, -0.720764983692) ,
vec3(0.79862868993, -0.354037253546, -0.486672208702) ,
vec3(-0.497629732937, 0.337200870644, -0.79916219989) ,
vec3(-0.831327231753, -0.311802320963, 0.460080804195) ,
vec3(-0.984557575327, 0.164025291122, 0.0611725815844) ,
vec3(-0.802283462523, -0.521694553549, -0.290131071344) ,
vec3(0.522601793119, -0.40321753833, 0.751201026765) ,
vec3(0.955735309743, 0.237918584641, -0.17310333559) ,
vec3(-0.878090077937, 0.212185673135, -0.428876503373) ,
vec3(-0.735865836141, 0.286394574736, 0.613579350013) ,
vec3(0.379077570937, -0.921141557617, -0.0883086974338) ,
vec3(0.463473014237, -0.180266935442, -0.867580887906) ,
vec3(-0.59301152411, -0.801056676216, 0.0815201432955) ,
vec3(-0.123782309361, 0.988831030019, -0.0830128541851) );




void find_blockers(vec3 worldPos, vec3 lightPos,  float blocker_radius, out float avg_blocker_depth, out float num_blockers)
{
	avg_blocker_depth = 0;
	num_blockers = 0;

	for (int i = 0; i < 32;++i)	
	{
		vec3 vert_to_light = worldPos - (lightPos +poisson_pcf[i]*blocker_radius);
		float cm_depth = texture(cubeMap,vert_to_light).r;
		float depth = length(vert_to_light);
		cm_depth *= far;
	
		if(cm_depth +BIAS  < depth)
		{
			avg_blocker_depth += cm_depth;
			num_blockers = num_blockers +1;
		}
		

	}
	avg_blocker_depth = avg_blocker_depth / max(num_blockers,1);
}


float pcf(vec3 worldPos, vec3 lightPos, float rad)
{
	float sf = 0.0f;
	for (int i =0; i< 32;++i)
	{
		vec3 vert_to_light = worldPos - (lightPos +poisson_pcf[i]*rad);
		float cm_depth = texture(cubeMap,vert_to_light).r;
		float depth = length(vert_to_light);
		cm_depth *= far;
	
		if(cm_depth +BIAS  >= depth)
		{
			sf += 1.0f;
		}
	}
	return sf / 32.0f;
}
float CalculateShadowFactor(vec3 worldPos, vec3 lightPos)
{
	float dist = distance(lightPos, worldPos);
	
	float blocker_radius =w_light* (dist - near)/dist;
	float num_blockers = 0;
	float avg_blocker_depth = 0.0;

	find_blockers(worldPos, lightPos, blocker_radius, avg_blocker_depth,num_blockers);

	if(num_blockers == 0)
		return 1.0;


	float penumbraRadius = w_light * (dist - avg_blocker_depth) / avg_blocker_depth;
	return pcf(worldPos, lightPos, penumbraRadius);
	
}
